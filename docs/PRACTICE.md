## 📝 면접 대비 핵심 포인트

### Q1: 대량 주문 시 어떻게 처리하나요?

> "앞단에서 Rate Limiter로 과도한 트래픽을 제어하고, 핫패스를 최소화하여 주문 저장과 Outbox 기록만 동기로 처리합니다. 결제와 알림은 Kafka를 통해 비동기로 처리하여 응답 시간을 200ms 이내로 유지합니다."

### Q2: 결제 실패 시 어떻게 처리하나요?

> "SAGA 패턴으로 보상 트랜잭션을 실행합니다. 결제 실패 이벤트를 수신하면 SAGA Coordinator가 재고 롤백과 주문 취소를 순차적으로 실행합니다. 각 단계가 실패해도 이벤트 기반이므로 재시도가 가능합니다."

### Q3: 중복 주문을 어떻게 방지하나요?

> "클라이언트에서 UUID 기반 멱등키를 생성하여 요청합니다. 서버는 Redis에 멱등키를 TTL과 함께 저장하고, 동일 키로 재요청 시 저장된 응답을 반환합니다. 상태 전이는 상태 머신으로 관리하여 PENDING에서 CONFIRMED로 한 번만 전이됩니다."

### Q4: 캐시 스탬피드를 어떻게 방지하나요?

> "Singleflight 패턴을 적용합니다. 동일 키에 대한 동시 요청 중 하나만 DB를 조회하고, 나머지는 결과를 공유받습니다. Redis의 SETNX로 분산 락을 구현하여 여러 서버에서도 동작합니다."

### Q5: DB 샤딩 전략은?

> "가게ID를 샤드 키로 사용합니다. 특정 가게에 주문이 몰려도 해당 샤드만 영향받아 핫 파티션을 방지합니다. Consistent Hashing으로 샤드 추가 시 데이터 이동을 최소화합니다."

> **Consistent Hashing:** 해시 링(Hash Ring) 구조를 사용하여, 샤드 개수가 변할 때 데이터 재분배(Rebalancing) 비용을 최소화하는 알고리즘입니다. 일반적인 Modulo 연산과 달리, 서버가 추가되어도 인접한 일부 데이터만 이동하면 되므로 시스템 확장 시 안정적입니다. 또한 **가상 노드(Virtual Node)**를 도입하여 데이터가 특정 샤드에 쏠리는 현상(Hot Partition)을 방지할 수 있습니다.

### Q6: 읽기 부하는 어떻게 처리하나요?

> "CQRS 패턴으로 쓰기와 읽기를 분리합니다. 쓰기는 Master DB로, 읽기는 Replica DB와 Elasticsearch로 분산합니다. 주문 목록은 캐시로, 검색은 Elasticsearch로 처리하여 쓰기 DB 부하를 격리합니다."

### Q7: 분산 추적은 어떻게 하나요?

> "API Gateway에서 모든 요청에 Trace ID를 주입합니다. 각 서비스는 Trace ID를 전파하며, Zipkin으로 전송합니다. 이를 통해 요청의 전체 흐름과 각 구간별 지연 시간을 시각화하여 병목을 분석합니다."

### Q8: 실시간 모니터링은?

> "Kafka에서 Flink로 이벤트를 스트리밍합니다. Flink는 5분 윈도우로 주문량을 집계하고, 평소 대비 10배 이상 급증하면 이상 탐지 알림을 발송합니다. 상태는 RocksDB에 저장하여 장애 시 Checkpoint에서 복구합니다."
